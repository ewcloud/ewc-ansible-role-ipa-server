---
- name: Validate user inputs
  ansible.builtin.assert:
    that:
      - ipa_domain is string and ipa_domain is defined and ipa_domain != ''
      - ipa_server_hostname is string and ipa_server_hostname is defined and ipa_server_hostname != ''
      - ipa_admin_password is string and ipa_admin_password is defined and ipa_admin_password != ''
      - ipa_admin_username is string and ipa_admin_username is defined and ipa_admin_username != ''
      - ipa_admin_givenname is string and ipa_admin_givenname is defined and ipa_admin_givenname != ''
      - ipa_admin_surname is string and ipa_admin_surname is defined and ipa_admin_surname != ''
      - os_auth_url is string and os_auth_url is defined and os_auth_url != ''
      - os_username is string and os_username is defined and os_username != ''
      - os_password is string and  os_password is defined and os_password != ''
      - os_project_name is string and os_project_name is defined and os_project_name != ''
      - os_network_name is string and os_network_name is defined and os_network_name != ''
      - os_subnet_name is string and os_subnet_name is defined and os_subnet_name != ''
      - os_subnet_cidr is string and os_subnet_cidr is defined and os_subnet_cidr != ''
      - os_security_group_name is string and os_security_group_name is defined and os_security_group_name != ''
      - os_subnet_dns_nameserver_ip_default is string and os_subnet_dns_nameserver_ip_default is defined and os_subnet_dns_nameserver_ip_default != ''
      - os_subnet_dns_nameserver_ip_fallback is string and os_subnet_dns_nameserver_ip_fallback is defined and os_subnet_dns_nameserver_ip_fallback != ''
    fail_msg: "Input validation failed. See README.md for information on required inputs and their format."
    success_msg: "User input configuration is valid."

- name: Gather information about user-specified OpenStack network
  openstack.cloud.networks_info:
    name: "{{ os_network_name }}"
    auth:
      auth_url: "{{ os_auth_url }}"
      username: "{{ os_username }}"
      password: "{{ os_password }}"
      project_name: "{{ os_project_name }}"
  register: networks_info
  delegate_to: localhost
  become: false

- name: Assert user-specified OpenStack network exists
  ansible.builtin.assert:
    that:
      - networks_info.networks | length > 0
    fail_msg: "OpenStack network '{{ os_network_name }}' does not exist."
    success_msg: "OpenStack network '{{ os_network_name }}' exists."
  delegate_to: localhost
  become: false

- name: Gather information about OpenStack subnet
  openstack.cloud.subnets_info:
    name: "{{ os_subnet_name }}"
    auth:
      auth_url: "{{ os_auth_url }}"
      username: "{{ os_username }}"
      password: "{{ os_password }}"
      project_name: "{{ os_project_name }}"
  register: subnets_info
  delegate_to: localhost
  become: false

- name: Assert user-specified OpenStack subnet exists
  ansible.builtin.assert:
    that:
      - subnets_info.subnets | length > 0
    fail_msg: "OpenStack subnet '{{ os_subnet_name }}' does not exist in network '{{ os_network_name }}'."
    success_msg: "OpenStack subnet '{{ os_subnet_name }}' exists in network '{{ os_network_name }}'."
  delegate_to: localhost
  become: false

- name: Gather information about OpenStack security group
  openstack.cloud.security_group_info:
    name: "{{ os_security_group_name }}"
    auth:
      auth_url: "{{ os_auth_url }}"
      username: "{{ os_username }}"
      password: "{{ os_password }}"
      project_name: "{{ os_project_name }}"
  register: security_group_info
  delegate_to: localhost
  become: false

- name: Assert user-specified OpenStack security group exists
  ansible.builtin.assert:
    that:
      - security_group_info.security_groups | length > 0
    fail_msg: "OpenStack security group '{{ os_security_group_name }}' does not exist."
    success_msg: "OpenStack security group '{{ os_security_group_name }}' exists."
  delegate_to: localhost
  become: false

- name: Gather information about OpenStack security group rules
  openstack.cloud.security_group_rule_info:
    security_group: "{{ os_security_group_name }}"
    auth:
      auth_url: "{{ os_auth_url }}"
      username: "{{ os_username }}"
      password: "{{ os_password }}"
      project_name: "{{ os_project_name }}"
  register: security_group_rule_info
  delegate_to: localhost
  become: false

- name: Define OpenStack security group rules required for IPA
  ansible.builtin.set_fact:
    required_security_rules:
      - direction: ingress
        ether_type: IPv4
        protocol: tcp
        port_range_min: 80
        port_range_max: 80
        remote_ip_prefix: 0.0.0.0/0
      - direction: ingress
        ether_type: IPv4
        protocol: udp
        port_range_min: 123
        port_range_max: 123
        remote_ip_prefix: 0.0.0.0/0
      - direction: ingress
        ether_type: IPv4
        protocol: tcp
        port_range_min: 88
        port_range_max: 88
        remote_ip_prefix: 0.0.0.0/0
      - direction: ingress
        ether_type: IPv4
        protocol: udp
        port_range_min: 88
        port_range_max: 88
        remote_ip_prefix: 0.0.0.0/0
      - direction: ingress
        ether_type: IPv4
        protocol: tcp
        port_range_min: 53
        port_range_max: 53
        remote_ip_prefix: 0.0.0.0/0
      - direction: ingress
        ether_type: IPv4
        protocol: udp
        port_range_min: 53
        port_range_max: 53
        remote_ip_prefix: 0.0.0.0/0
      - direction: ingress
        ether_type: IPv4
        protocol: tcp
        port_range_min: 389
        port_range_max: 389
        remote_ip_prefix: 0.0.0.0/0
      - direction: ingress
        ether_type: IPv4
        protocol: tcp
        port_range_min: 749
        port_range_max: 749
        remote_ip_prefix: 0.0.0.0/0
      - direction: ingress
        ether_type: IPv4
        protocol: tcp
        port_range_min: 22
        port_range_max: 22
        remote_ip_prefix: 0.0.0.0/0
      - direction: ingress
        ether_type: IPv4
        protocol: tcp
        port_range_min: 636
        port_range_max: 636
        remote_ip_prefix: 0.0.0.0/0
      - direction: ingress
        ether_type: IPv4
        protocol: tcp
        port_range_min: 464
        port_range_max: 464
        remote_ip_prefix: 0.0.0.0/0
      - direction: ingress
        ether_type: IPv4
        protocol: udp
        port_range_min: 464
        port_range_max: 464
        remote_ip_prefix: 0.0.0.0/0
      - direction: ingress
        ether_type: IPv4
        protocol: tcp
        port_range_min: 443
        port_range_max: 443
        remote_ip_prefix: 0.0.0.0/0
  delegate_to: localhost
  become: false

- name: Verify required IPA security group rules exist (no custom filter)
  ansible.builtin.assert:
    that: >-
      {{
        security_group_rule_info.security_group_rules | selectattr('direction', 'equalto', item.direction)
                                                      | selectattr('ether_type', 'equalto', item.ether_type)
                                                      | selectattr('protocol', 'equalto', item.protocol)
                                                      | selectattr('port_range_min', 'equalto', item.port_range_min)
                                                      | selectattr('port_range_max', 'equalto', item.port_range_max)
                                                      | selectattr('remote_ip_prefix', 'equalto', item.remote_ip_prefix)
                                                      | list
                                                      | length > 0
      }}
    fail_msg: "Missing required security group rule: {{ item | to_json }}."
    success_msg: "Security group rule exists: {{ item | to_json }}."
  loop: "{{ required_security_rules }}"
  delegate_to: localhost
  become: false

- name: Verify RockyLinux distribution and version
  ansible.builtin.assert:
    that:
      - ansible_facts['distribution'] == 'Rocky'
      - ansible_facts['distribution_major_version'] in ['8', '9']
    fail_msg: "Supports RockyLinux versions 8 or 9. Detected: {{ ansible_facts['distribution'] }} {{ ansible_facts['distribution_major_version'] }}."
    success_msg: "Running on RockyLinux {{ ansible_facts['distribution_major_version'] }}."

- name: Verify RAM availability
  ansible.builtin.assert:
    that:
      - ansible_facts['memory_mb']['real']['free'] >= 2048
    fail_msg: "Insufficient free RAM (less than 2GB). Increase VM memory or add swap."
    success_msg: "Sufficient RAM available."

- name: Enable Red Hat Enterprise Linux Identity Management system module on RockyLinux 8
  ansible.builtin.dnf:
    name: "@idm:DL1"
    state: present
  when:
    - ansible_facts['distribution'] == 'Rocky' and ansible_facts['distribution_major_version'] == '8'

- name: Install required packages
  ansible.builtin.dnf:
    name:
      - firewalld
      - ipa-server
      - ipa-server-dns
      - bind-dyndb-ldap
      - dnf-automatic
    state: present

- name: SSH - Disallow root SSH access
  ansible.builtin.lineinfile:
    dest: /etc/ssh/sshd_config
    regexp: "^PermitRootLogin"
    line: "PermitRootLogin no"
    state: present
  notify: Restart sshd

- name: SElinux - Set permissive mode
  ansible.posix.selinux:
    policy: targeted
    state: permissive

- name: Set hostname
  ansible.builtin.hostname:
    name: "{{ ipa_server_hostname }}.{{ ipa_domain }}"
    use: systemd
  register: hostname_set
  changed_when: hostname_set.changed

- name: Persist hostname to /etc/hostname
  ansible.builtin.copy:
    dest: /etc/hostname
    content: "{{ ipa_server_hostname }}.{{ ipa_domain }}\n"
    mode: '0644'
  register: hostname_persist
  changed_when: hostname_persist.changed

- name: Add server /etc/hosts
  ansible.builtin.lineinfile:
    path: /etc/hosts
    regexp: '^{{ ansible_default_ipv4.address }}'
    line: '{{ ansible_default_ipv4.address }} {{ ipa_server_hostname }}.{{ ipa_domain }}'
    insertafter: BOF
    state: present

- name: Configure DNS server in NetworkManager
  community.general.nmcli:
    conn_name: "{{ ansible_default_ipv4.interface }}"
    type: ethernet
    dns4:
      - "127.0.0.1"
    state: present
  notify: Reload NetworkManager

- name: Check if FreeIPA is already installed
  ansible.builtin.stat:
    path: /etc/ipa/default.conf
  register: ipa_config_stat

- name: Install and configure the IPA server
  ansible.builtin.command:
    argv:
      - ipa-server-install
      - --unattended
      - --domain={{ ipa_domain }}
      - --mkhomedir
      - --setup-dns
      - --auto-reverse
      - --forwarder={{ os_subnet_dns_nameserver_ip_default }}
      - --forwarder={{ os_subnet_dns_nameserver_ip_fallback }}
      - --realm={{ ipa_domain | upper }}
      - --hostname={{ ipa_server_hostname }}.{{ ipa_domain }}
      - --ds-password={{ ipa_admin_password }}
      - --admin-password={{ ipa_admin_password }}
    creates: /etc/ipa/default.conf
  when: not ipa_config_stat.stat.exists
  register: ipa_install_result
  failed_when: ipa_install_result.rc != 0 and 'already installed' not in ipa_install_result.stderr
  no_log: true

- name: Configure DNF-automatic update_type
  ansible.builtin.lineinfile:
    path: /etc/dnf/automatic.conf
    regexp: "^upgrade_type"
    line: "upgrade_type = security"
    state: present

- name: Configure DNF-automatic download_updates
  ansible.builtin.lineinfile:
    path: /etc/dnf/automatic.conf
    regexp: "^download_updates"
    line: "download_updates = yes"
    state: present

- name: Configure DNF-automatic apply_updates
  ansible.builtin.lineinfile:
    path: /etc/dnf/automatic.conf
    regexp: "^apply_updates"
    line: "apply_updates = yes"
    state: present

- name: IPA services - Enabled and started
  ansible.builtin.systemd:
    name: ipa
    enabled: true
    state: started

- name: DNF-automatic - Enabled and started
  ansible.builtin.systemd:
    name: dnf-automatic.timer
    enabled: true
    state: started

- name: Firewalld - Disabled and stopped
  ansible.builtin.service:
    name: firewalld
    state: stopped
    enabled: false

- name: Authenticate as IPA admin with Kerberos
  ansible.builtin.command:
    cmd: bash -c "echo '{{ ipa_admin_password }}' | kinit admin"
  register: kinit_result
  failed_when: kinit_result.rc != 0
  changed_when: false
  no_log: true

- name: Add new user-defined IPA admin
  community.general.ipa_user:
    uid: "{{ ipa_admin_username }}"
    givenname: "{{ ipa_admin_givenname }}"
    sn: "{{ ipa_admin_surname }}"
    password: "{{ ipa_admin_password }}"
    ipa_pass: "{{ ipa_admin_password }}"
    ipa_host: "{{ ipa_server_hostname }}.{{ ipa_domain }}"
    state: present
  register: ipa_user_result
  no_log: true

- name: Elevate new user-defined admin to super user on IPA server itself
  ansible.builtin.lineinfile:
    path: /etc/sudoers
    line: "{{ ipa_admin_username }} ALL=(ALL) ALL"
    validate: 'visudo -cf %s'
    state: present

- name: Create IPA sudo rule
  community.general.ipa_sudorule:
    ipa_pass: "{{ ipa_admin_password }}"
    ipa_host: "{{ ipa_server_hostname }}.{{ ipa_domain }}"
    name: admin_sudo_rule
    description: "Sudo rule for IPA admin user"
    user: "{{ ipa_admin_username }}"
    hostcategory: all
    cmdcategory: all
    runasusercategory: all
    runasgroupcategory: all
    state: present
  register: ipa_sudorule_result
  no_log: true

- name: Include the new user-defined IPA admin in admins group
  community.general.ipa_group:
    ipa_pass: "{{ ipa_admin_password }}"
    ipa_host: "{{ ipa_server_hostname }}.{{ ipa_domain }}"
    name: admins
    user: "{{ ipa_admin_username }}"
    append: true
    state: present
  register: ipa_group_admins_result
  no_log: true

- name: Include the new user-defined IPA admin in trust admins group
  community.general.ipa_group:
    ipa_pass: "{{ ipa_admin_password }}"
    ipa_host: "{{ ipa_server_hostname }}.{{ ipa_domain }}"
    name: trust admins
    user: "{{ ipa_admin_username }}"
    append: true
    state: present
  register: ipa_group_trust_admins_result
  no_log: true

- name: Set user-defined IPA admin password expire date as start of Unix Time (e.g. no expiration)
  community.general.ipa_user:
    ipa_pass: "{{ ipa_admin_password }}"
    ipa_host: "{{ ipa_server_hostname }}.{{ ipa_domain }}"
    uid: "{{ ipa_admin_username }}"
    krbpasswordexpiration: 19700101000000
    state: present
  register: ipa_user_mod_result
  no_log: true

- name: Disable IPA default admin account
  community.general.ipa_user:
    ipa_pass: "{{ ipa_admin_password }}"
    ipa_host: "{{ ipa_server_hostname }}.{{ ipa_domain }}"
    uid: admin
    state: disabled
  register: ipa_admin_disable_result
  no_log: true

- name: Point DNS nameservers in OpenStack subnet to new IPA server
  openstack.cloud.subnet:
    name: "{{ os_subnet_name }}"
    network: "{{ os_network_name }}"
    cidr: "{{ os_subnet_cidr }}"
    dns_nameservers:
      - "{{ ansible_default_ipv4.address }}"
    state: present
    auth:
      auth_url: "{{ os_auth_url }}"
      username: "{{ os_username }}"
      password: "{{ os_password }}"
      project_name: "{{ os_project_name }}"
  register: subnet_result
  delegate_to: localhost
  become: false

- name: Gather package facts
  ansible.builtin.package_facts:
    manager: auto

- name: List installed package versions
  ansible.builtin.debug:
    msg:
      - "firewalld: {{ ansible_facts.packages['firewalld'][0].version }}-{{ ansible_facts.packages['firewalld'][0].release }}"
      - "ipa-server: {{ ansible_facts.packages['ipa-server'][0].version }}-{{ ansible_facts.packages['ipa-server'][0].release }}"
      - "ipa-server-dns: {{ ansible_facts.packages['ipa-server-dns'][0].version }}-{{ ansible_facts.packages['ipa-server-dns'][0].release }}"
      - "bind-dyndb-ldap: {{ ansible_facts.packages['bind-dyndb-ldap'][0].version }}-{{ ansible_facts.packages['bind-dyndb-ldap'][0].release }}"
      - "dnf-automatic: {{ ansible_facts.packages['dnf-automatic'][0].version }}-{{ ansible_facts.packages['dnf-automatic'][0].release }}"
