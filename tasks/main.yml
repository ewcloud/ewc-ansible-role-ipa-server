---
- name: Validate user inputs
  ansible.builtin.assert:
    that:
      - ipa_domain is string and ipa_domain is defined and ipa_domain != ''
      - ipa_server_hostname is string and ipa_server_hostname is defined and ipa_server_hostname != ''
      - ipa_admin_password is string and ipa_admin_password is defined and ipa_admin_password != ''
      - ipa_admin_password | length >= 8
      - ipa_admin_username is string and ipa_admin_username is defined and ipa_admin_username != ''
      - ipa_admin_givenname is string and ipa_admin_givenname is defined and ipa_admin_givenname != ''
      - ipa_admin_surname is string and ipa_admin_surname is defined and ipa_admin_surname != ''
      - os_network_name is string and os_network_name is defined and os_network_name != ''
      - os_security_group_name is string and os_security_group_name is defined and os_security_group_name != ''
    fail_msg: "Input validation failed. See README.md for information on required inputs and their format."
    success_msg: "User input configuration is valid."

- name: Gather information about user-specified OpenStack network
  openstack.cloud.networks_info:
    name: "{{ os_network_name }}"
  register: networks_info
  delegate_to: localhost
  become: false

- name: Verify user-specified OpenStack network exists
  ansible.builtin.assert:
    that:
      - networks_info.networks | length > 0
      - networks_info.networks | length == 1
    fail_msg: "OpenStack network '{{ os_network_name }}' does not exist or is not unique."
    success_msg: "OpenStack network '{{ os_network_name }}' exists."

- name: Get ID of user-defined network
  ansible.builtin.set_fact:
    os_network_id: "{{ networks_info.networks[0].id }}"

- name: Gather information about subnets within user-defined OpenStack network
  openstack.cloud.subnets_info:
    filters:
      network_id: "{{ os_network_id }}"
  register: subnets_info
  delegate_to: localhost
  become: false

- name: Verify OpenStack subnets are available within user-defined network
  ansible.builtin.assert:
    that:
      - subnets_info.subnets | length > 0
    fail_msg: " No OpenStack subnets exist in network '{{ os_network_name }}'."
    success_msg: "A total of {{ subnets_info.subnets | length }} OpenStack subnet(s) available in network '{{ os_network_name }}'."

- name: Get name, ID, CIDR and DNS nameservers of subnet (choose first)
  ansible.builtin.set_fact:
    os_subnet_name: "{{ subnets_info.subnets[0].name }}"
    os_subnet_cidr: "{{ subnets_info.subnets[0].cidr }}"
    os_subnet_dns_nameservers: "{{ subnets_info.subnets[0].dns_nameservers | default([]) }}"

- name: Verify chosen subnet has at least two DNS nameservers set
  ansible.builtin.assert:
    that:
      - os_subnet_dns_nameservers | length > 0
    fail_msg: "Subnet '{{ os_subnet_name }}' has no DNS nameservers configured"
    success_msg: "The following DNS nameservers are set in subnet '{{ os_subnet_name }}': {{ os_subnet_dns_nameservers }}"

- name: Gather information about OpenStack security group
  openstack.cloud.security_group_info:
    name: "{{ os_security_group_name }}"
  register: security_group_info
  delegate_to: localhost
  become: false

- name: Verify user-specified OpenStack security group exists
  ansible.builtin.assert:
    that:
      - security_group_info.security_groups | length > 0
      - security_group_info.security_groups | length == 1
    fail_msg: "OpenStack security group '{{ os_security_group_name }}' does not exist or is not unique."
    success_msg: "OpenStack security group '{{ os_security_group_name }}' exists."

- name: Verify RockyLinux distribution and version
  ansible.builtin.assert:
    that:
      - ansible_facts['distribution'] == 'Rocky'
      - ansible_facts['distribution_version'] in ['8.10', '9.5']
    fail_msg: "Supports RockyLinux versions 8.10 or 9.5. Detected: {{ ansible_facts['distribution'] }} {{ ansible_facts['distribution_version'] }}."
    success_msg: "Running on RockyLinux {{ ansible_facts['distribution_version'] }}."

- name: Pin package versions prior to installation
  ansible.builtin.set_fact:
    package_versions:
      rockylinux_8:
        ipa-server: "ipa-server-4.9.13-18.module+el8.10.0+2000+979bf254"
        ipa-server-dns: "ipa-server-dns-4.9.13-18.module+el8.10.0+2000+979bf254"
        bind-dyndb-ldap: "bind-dyndb-ldap-11.6-6.module+el8.10.0+1960+1ed527b3"
      rockylinux_9:
        ipa-server: "ipa-server-4.12.2-14.el9_6.1"
        ipa-server-dns: "ipa-server-dns-4.12.2-14.el9_6.1"
        bind-dyndb-ldap: "bind-dyndb-ldap-11.11-3.el9_6"

- name: Enable Red Hat Enterprise Linux Identity Management system module on RockyLinux 8
  ansible.builtin.dnf:
    name: "@idm:DL1"
    state: present
  when:
    - ansible_facts['distribution'] == 'Rocky' and ansible_facts['distribution_major_version'] == '8'

- name: Install required packages
  ansible.builtin.dnf:
    name:
      - "{{ item }}"
    state: present
    allow_downgrade: true
  loop:
    - "{{ package_versions['rockylinux_' + ansible_facts['distribution_major_version']]['ipa-server'] }}"
    - "{{ package_versions['rockylinux_' + ansible_facts['distribution_major_version']]['ipa-server-dns'] }}"
    - "{{ package_versions['rockylinux_' + ansible_facts['distribution_major_version']]['bind-dyndb-ldap'] }}"

- name: SSH - Disallow root SSH access
  ansible.builtin.lineinfile:
    dest: /etc/ssh/sshd_config
    regexp: "^PermitRootLogin"
    line: "PermitRootLogin no"
    state: present
  notify: Restart sshd

- name: SElinux - Set permissive mode
  ansible.posix.selinux:
    policy: targeted
    state: permissive

- name: Set hostname
  ansible.builtin.hostname:
    name: "{{ ipa_server_hostname }}.{{ ipa_domain }}"
    use: systemd
  register: hostname_set
  changed_when: hostname_set.changed

- name: Persist hostname to /etc/hostname
  ansible.builtin.copy:
    dest: /etc/hostname
    content: "{{ ipa_server_hostname }}.{{ ipa_domain }}\n"
    mode: '0644'
  register: hostname_persist
  changed_when: hostname_persist.changed

- name: Add server /etc/hosts
  ansible.builtin.lineinfile:
    path: /etc/hosts
    regexp: '^{{ ansible_default_ipv4.address }}'
    line: '{{ ansible_default_ipv4.address }} {{ ipa_server_hostname }}.{{ ipa_domain }}'
    insertafter: BOF
    state: present

- name: Configure DNS server in NetworkManager
  community.general.nmcli:
    conn_name: "{{ ansible_default_ipv4.interface }}"
    type: ethernet
    dns4:
      - "127.0.0.1"
    state: present
  notify: Reload NetworkManager

- name: Check if FreeIPA is already installed
  ansible.builtin.stat:
    path: /etc/ipa/default.conf
  register: ipa_config_stat

- name: Install and configure the IPA server
  ansible.builtin.command:
    argv:
      - ipa-server-install
      - --unattended
      - --domain={{ ipa_domain }}
      - --mkhomedir
      - --setup-dns
      - --auto-reverse
      - --forwarder={{ os_subnet_dns_nameservers[0] }}
      - --forwarder={{ os_subnet_dns_nameservers[1] | default(omit) }}
      - --realm={{ ipa_domain | upper }}
      - --hostname={{ ipa_server_hostname }}.{{ ipa_domain }}
      - --ds-password={{ ipa_admin_password }}
      - --admin-password={{ ipa_admin_password }}
    creates: /etc/ipa/default.conf
  when: not ipa_config_stat.stat.exists
  register: ipa_install_result
  failed_when: ipa_install_result.rc != 0 and 'already installed' not in ipa_install_result.stderr
  no_log: true

- name: IPA services - Enabled and started
  ansible.builtin.systemd:
    name: ipa
    enabled: true
    state: started

- name: Firewalld - Disabled and stopped
  ansible.builtin.service:
    name: firewalld
    state: stopped
    enabled: false

- name: Check if default IPA admin account is still enabled
  community.general.ipa_user:
    ipa_pass: "{{ ipa_admin_password }}"
    ipa_host: "{{ ipa_server_hostname }}.{{ ipa_domain }}"
    uid: admin
    state: present
  register: default_admin
  failed_when: false
  no_log: true

- name: Check if user-defined IPA admin account exists
  community.general.ipa_user:
    ipa_pass: "{{ ipa_admin_password }}"
    ipa_host: "{{ ipa_server_hostname }}.{{ ipa_domain }}"
    uid: "{{ ipa_admin_username }}"
    state: present
  register: user_defined_admin
  failed_when: false
  no_log: true

- name: Set flag for tasks conditioned to successful completion of first configuration
  ansible.builtin.set_fact:
    is_initial_configuration: "{{ default_admin.get('user', []) | length > 0 and 'is required' in user_defined_admin.get('msg', '') }}"

- name: Add new user-defined IPA admin
  community.general.ipa_user:
    uid: "{{ ipa_admin_username }}"
    givenname: "{{ ipa_admin_givenname }}"
    sn: "{{ ipa_admin_surname }}"
    password: "{{ ipa_admin_password }}"
    ipa_pass: "{{ ipa_admin_password }}"
    ipa_host: "{{ ipa_server_hostname }}.{{ ipa_domain }}"
    state: present
  when: is_initial_configuration
  register: ipa_user_result
  no_log: true

- name: Create IPA sudo rule
  community.general.ipa_sudorule:
    ipa_pass: "{{ ipa_admin_password }}"
    ipa_host: "{{ ipa_server_hostname }}.{{ ipa_domain }}"
    name: admin_sudo_rule
    description: "Sudo rule for IPA admin user"
    user: "{{ ipa_admin_username }}"
    hostcategory: all
    cmdcategory: all
    runasusercategory: all
    runasgroupcategory: all
    state: present
  when: is_initial_configuration
  register: ipa_sudorule_result
  no_log: true

- name: Include the new user-defined IPA admin in admins group
  community.general.ipa_group:
    ipa_pass: "{{ ipa_admin_password }}"
    ipa_host: "{{ ipa_server_hostname }}.{{ ipa_domain }}"
    name: admins
    user: "{{ ipa_admin_username }}"
    append: true
    state: present
  when: is_initial_configuration
  register: ipa_group_admins_result
  no_log: true

- name: Include the new user-defined IPA admin in trust admins group
  community.general.ipa_group:
    ipa_pass: "{{ ipa_admin_password }}"
    ipa_host: "{{ ipa_server_hostname }}.{{ ipa_domain }}"
    name: trust admins
    user: "{{ ipa_admin_username }}"
    append: true
    state: present
  when: is_initial_configuration
  register: ipa_group_trust_admins_result
  no_log: true

- name: Set user-defined IPA admin password expire date as start of Unix Time (e.g. no expiration)
  community.general.ipa_user:
    ipa_pass: "{{ ipa_admin_password }}"
    ipa_host: "{{ ipa_server_hostname }}.{{ ipa_domain }}"
    uid: "{{ ipa_admin_username }}"
    krbpasswordexpiration: 19700101000000
    state: present
  when: is_initial_configuration
  register: ipa_user_mod_result
  no_log: true

- name: Disable IPA default admin account
  community.general.ipa_user:
    ipa_pass: "{{ ipa_admin_password }}"
    ipa_host: "{{ ipa_server_hostname }}.{{ ipa_domain }}"
    uid: admin
    state: disabled
  when: is_initial_configuration
  register: ipa_admin_disable_result
  no_log: true

- name: Point DNS nameservers in OpenStack subnet to new IPA server
  openstack.cloud.subnet:
    name: "{{ os_subnet_name }}"
    network: "{{ os_network_name }}"
    cidr: "{{ os_subnet_cidr }}"
    dns_nameservers:
      - "{{ ansible_default_ipv4.address }}"
    state: present
  register: subnet_result
  delegate_to: localhost
  become: false
  no_log: true

- name: Gather package facts
  ansible.builtin.package_facts:
    manager: auto

- name: List installed package versions
  ansible.builtin.debug:
    msg:
      - "ipa-server: {{ ansible_facts.packages['ipa-server'][0].version }}-{{ ansible_facts.packages['ipa-server'][0].release }}"
      - "ipa-server-dns: {{ ansible_facts.packages['ipa-server-dns'][0].version }}-{{ ansible_facts.packages['ipa-server-dns'][0].release }}"
      - "bind-dyndb-ldap: {{ ansible_facts.packages['bind-dyndb-ldap'][0].version }}-{{ ansible_facts.packages['bind-dyndb-ldap'][0].release }}"

- name: List verified and/or updated OpenStack resources
  ansible.builtin.debug:
    msg:
      - "OpenStack Network: '{{ os_network_name }}'"
      - "OpenStack Subnet: '{{ os_subnet_name }}'"
      - "OpenStack Subnet DNS nameservers: ['{{ ansible_default_ipv4.address }}']"
